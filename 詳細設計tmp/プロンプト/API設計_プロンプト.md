# API設計作成プロンプト

## 目的
要件定義書の内容を基に、フロントエンドとバックエンド、または外部システムとの通信を実現するためのAPI設計書を作成します。

## インプット
以下のドキュメントを読み込んでください：
1. **要件定義書**: `[要件定義書のパス]`
2. **システム構成図**: `詳細設計tmp/システム構成図.md`
3. **DB設計書**: `詳細設計tmp/DB設計.md`

## 出力指示
`詳細設計tmp/テンプレート/API設計.md` のテンプレートを使用して、API設計書を作成してください。

## 作成ガイドライン

### 1. 要件定義書の分析
まず、以下の情報を要件定義書から抽出してください：

#### 1.1 機能要件の分析
- **画面一覧**: 各画面で必要なデータ取得・更新API
- **業務フロー**: フロー内で発生するAPI呼び出しを特定
- **データ操作**: CRUD操作（作成・読取・更新・削除）の洗い出し
- **外部連携**: 外部システムとの連携要件

#### 1.2 非機能要件の確認
- **性能要件**: レスポンスタイム目標 → キャッシュ戦略、最適化
- **セキュリティ要件**: 認証方式、暗号化要件
- **可用性要件**: エラーハンドリング、リトライポリシー
- **同時アクセス数**: レート制限の設定

#### 1.3 データ要件との整合
- DB設計書のテーブル定義とAPIのリクエスト/レスポンスを対応付け
- エンティティとAPIリソースのマッピング

### 2. API設計の進め方

#### ステップ1: API設計方針の決定
1. **アーキテクチャスタイルの選定**:
   - RESTful API: 標準的なWebアプリケーション（推奨）
   - GraphQL: 複雑なデータ取得、フロントエンド主導
   - gRPC: マイクロサービス間通信、高性能要求
   - 理由を要件と紐付けて説明

2. **命名規則の定義**:
   - エンドポイント: `/api/v1/users`（複数形、ケバブケース）
   - JSONキー: `camelCase` or `snake_case`（統一）
   - 一貫性を保つ

3. **バージョニング方針**:
   - URLパスに含める: `/api/v1/`（推奨）
   - ヘッダーに含める: `Accept: application/vnd.api+json; version=1`
   - 後方互換性ポリシーを明確化

#### ステップ2: 認証・認可の設計
1. **認証方式の選定**:
   - JWT (JSON Web Token): ステートレス、スケーラブル（推奨）
   - セッションベース: 伝統的、サーバー側で管理
   - OAuth 2.0: 外部サービス連携
   - API Key: 内部システム、単純な用途

2. **認可モデル**:
   - RBAC (Role-Based Access Control): ロールベース
   - ABAC (Attribute-Based Access Control): 属性ベース
   - エンドポイントごとに必要なロールを定義

3. **トークン管理**:
   - アクセストークン: 短い有効期限（1時間など）
   - リフレッシュトークン: 長い有効期限（30日など）
   - トークン更新フロー

#### ステップ3: エンドポイントの設計
1. **リソースの特定**:
   - 要件から管理対象のリソースを洗い出し（ユーザー、商品、注文など）
   - DB設計のテーブルと対応

2. **RESTfulな設計**:
   - リソース指向のURL設計
   - HTTPメソッドの適切な使用
     - GET: 取得
     - POST: 作成
     - PUT: 全体更新
     - PATCH: 部分更新
     - DELETE: 削除

3. **エンドポイント一覧の作成**:
   - リソースごとにCRUD操作を定義
   - 必要な認証・ロールを明記

### 3. 各セクションの作成指示

#### 3.1 API設計方針 (セクション3)
- アーキテクチャスタイル、通信プロトコル、データフォーマット
- 命名規則、バージョニング方針
- レート制限（同時アクセス数要件から設定）
- 要件との関連性を明記

#### 3.2 認証・認可 (セクション4)
- 認証方式の選定と理由
- トークン形式、有効期限
- 認可モデル（RBAC/ABAC）
- 認証フローの図示（シーケンス図）

#### 3.3 エラーハンドリング (セクション5)
**HTTPステータスコードの使い分け**:
- 2xx: 成功
  - 200 OK: 成功（GET, PUT）
  - 201 Created: 作成成功（POST）
  - 204 No Content: 成功、レスポンスボディなし（DELETE）
- 4xx: クライアントエラー
  - 400 Bad Request: バリデーションエラー
  - 401 Unauthorized: 認証エラー
  - 403 Forbidden: 認可エラー
  - 404 Not Found: リソース未存在
  - 409 Conflict: 一意制約違反
  - 422 Unprocessable Entity: ビジネスロジックエラー
  - 429 Too Many Requests: レート制限超過
- 5xx: サーバーエラー
  - 500 Internal Server Error: 予期しないエラー
  - 503 Service Unavailable: メンテナンス中

**エラーレスポンス形式の統一**:
- エラーコード、メッセージ、詳細（フィールドごと）
- リクエストID（トレーサビリティ）
- タイムスタンプ

#### 3.4 API一覧 (セクション6)
全エンドポイントの一覧表を作成:
- エンドポイント、HTTPメソッド、概要
- 必要な認証、ロール
- 機能要件との対応を明記

#### 3.5 API詳細仕様 (セクション7)
各APIについて以下を詳細に定義:

**基本情報**:
- エンドポイント、HTTPメソッド
- 概要（どの機能で使われるか）
- 認証要否、ロール
- レート制限

**リクエスト仕様**:
- パスパラメータ、クエリパラメータ、リクエストボディ
- 各パラメータの型、必須/任意、説明、バリデーション
- サンプルリクエスト（JSON）

**レスポンス仕様**:
- 成功時のレスポンス（200, 201など）
- 各フィールドの型、説明
- サンプルレスポンス（JSON）
- エラー時のレスポンス（各エラーケース）

**バリデーション**:
- 文字列長、数値範囲、フォーマット（メールアドレス、日付など）
- 必須チェック、一意性チェック
- ビジネスルール（例: 注文金額は0以上）

**DB設計との対応**:
- どのテーブルを参照・更新するか明記
- リクエストパラメータとカラムの対応
- レスポンスフィールドとカラムの対応

#### 3.6 ページネーション (セクション8)
一覧取得APIで使用:
- ページネーション方式（オフセットベース/カーソルベース）
- デフォルトページサイズ、最大ページサイズ
- レスポンス形式（currentPage, totalPages, totalCount, hasNextなど）

#### 3.7 フィルタリング・ソート・検索 (セクション9)
一覧取得APIの機能拡張:
- フィルタリング: クエリパラメータで条件指定
- ソート: sort, order パラメータ
- 検索: search パラメータ、対象フィールド
- 例: `?role=admin&sort=created_at&order=desc&search=yamada`

#### 3.8 外部API連携 (セクション10)
外部システム連携要件がある場合:
- 連携先、用途、プロトコル、認証方式
- エンドポイント、リクエスト/レスポンス形式
- エラーハンドリング、リトライポリシー
- タイムアウト設定

#### 3.9 Webhook (セクション11)
イベント駆動の連携が必要な場合:
- イベント一覧、発火タイミング
- ペイロード形式
- 署名検証方法（HMAC-SHA256など）
- リトライポリシー

#### 3.10 パフォーマンス (セクション12)
- **レスポンスタイム目標**: 性能要件から設定
- **キャッシュ戦略**:
  - マスターデータ: 長時間キャッシュ
  - 動的データ: 短時間キャッシュまたはキャッシュなし
  - キャッシュ方式（サーバーサイド、CDN、ブラウザ）
- **圧縮**: gzip圧縮の有効化

#### 3.11 セキュリティ (セクション13)
- **CORS設定**: 許可オリジン、メソッド、ヘッダー
- **HTTPS強制**: すべてのAPI通信を暗号化
- **入力値検証**:
  - SQLインジェクション対策（ORMまたはプリペアドステートメント）
  - XSS対策（出力時エスケープ）
  - CSRF対策（トークン検証、必要に応じて）
- **機密情報の取り扱い**:
  - パスワードハッシュ化（bcrypt）
  - APIレスポンスに機密情報を含めない
  - ログにパスワード等を出力しない

#### 3.12 ロギング・監視 (セクション14)
- **ログ出力**:
  - アクセスログ（リクエスト/レスポンス）
  - エラーログ（スタックトレース）
  - 監査ログ（重要操作）
  - 保存期間
- **監視項目**:
  - エラー率、レスポンスタイム、リクエスト数
  - しきい値、アラート設定

#### 3.13 テスト (セクション15)
- テスト方針（単体、結合、負荷テスト）
- テストデータ（サンプルデータ、本番データは使わない）
- テストツール（Postman, Jest, etc.）

#### 3.14 API仕様書公開 (セクション16)
- OpenAPI 3.0形式で定義
- Swagger UIで公開
- インタラクティブなドキュメント提供

#### 3.15 変更管理 (セクション17)
- バージョニングポリシー
- 非推奨化プロセス（6ヶ月前告知など）
- 後方互換性の維持

#### 3.16 サンプルコード (セクション18)
- cURL
- JavaScript (fetch, axios)
- その他言語（Python, Java等）
- 開発者が使いやすい実装例を提供

### 4. API設計の重要ポイント

#### 4.1 RESTfulな設計原則
- **リソース指向**: URLはリソースを表現（動詞ではなく名詞）
  - ✓ `/api/v1/users/{id}`
  - ✗ `/api/v1/getUser?id=123`
- **HTTPメソッドの適切な使用**:
  - GET: 冪等、キャッシュ可能
  - POST: 非冪等、新規作成
  - PUT: 冪等、全体更新
  - DELETE: 冪等、削除
- **ステートレス**: 各リクエストは独立
- **階層構造**: ネストされたリソース
  - `/api/v1/users/{userId}/orders`

#### 4.2 一貫性の維持
- **命名規則**: 全エンドポイントで統一
- **データ形式**: JSONキーの命名（camelCase or snake_case）
- **エラーレスポンス形式**: 統一されたフォーマット
- **ページネーション**: 全一覧APIで同じ形式

#### 4.3 バリデーション
- **サーバーサイドで必ず検証**: クライアントサイドのみは不十分
- **具体的なエラーメッセージ**: どのフィールドがどう間違っているか
- **ビジネスルールの検証**: 例: 注文金額は在庫数を超えられない

#### 4.4 ドキュメント化
- **OpenAPI仕様**: 機械可読な形式で定義
- **サンプルリクエスト/レスポンス**: 実装者が理解しやすい
- **エラーケースの網羅**: 全エラーケースを記載
- **常に最新**: コードとドキュメントの同期

#### 4.5 パフォーマンス最適化
- **ページネーション**: 大量データの一覧取得
- **フィールド選択**: 必要なフィールドのみ返す（`?fields=id,name`）
- **キャッシュ**: 変更頻度の低いデータ
- **圧縮**: レスポンスサイズ削減

#### 4.6 セキュリティ対策
- **認証**: すべての保護されたエンドポイント
- **認可**: ロール/権限チェック
- **入力値検証**: インジェクション攻撃対策
- **レート制限**: DoS攻撃対策
- **HTTPS**: 通信の暗号化

### 5. チェックリスト
作成後、以下を確認してください：

**全体方針**
- [ ] API設計方針（RESTful/GraphQL等）が明確で、理由が記載されている
- [ ] 命名規則が定義され、全エンドポイントで統一されている
- [ ] バージョニング方針が明確である
- [ ] レート制限が設定されている

**認証・認可**
- [ ] 認証方式が選定され、理由が記載されている
- [ ] トークン管理（発行、更新、失効）が定義されている
- [ ] 各エンドポイントの認証要否が明確である
- [ ] 各エンドポイントに必要なロールが定義されている

**エンドポイント設計**
- [ ] 要件定義書の全機能がAPIでカバーされている
- [ ] RESTful原則に従っている（リソース指向、HTTPメソッド）
- [ ] URL設計が一貫している
- [ ] エンドポイント一覧が網羅的である

**API詳細仕様**
- [ ] 全エンドポイントの詳細仕様が記載されている
- [ ] リクエスト/レスポンスのサンプルがある
- [ ] パラメータのバリデーションが明確である
- [ ] エラーレスポンスが全ケースで定義されている
- [ ] DB設計との対応が明確である

**エラーハンドリング**
- [ ] HTTPステータスコードの使い分けが適切である
- [ ] エラーレスポンス形式が統一されている
- [ ] エラーコード一覧が定義されている
- [ ] ユーザーフレンドリーなエラーメッセージである

**パフォーマンス**
- [ ] レスポンスタイム目標が要件を満たしている
- [ ] ページネーションが一覧APIに実装されている
- [ ] キャッシュ戦略が定義されている
- [ ] 圧縮が有効化されている

**セキュリティ**
- [ ] HTTPS通信が強制されている
- [ ] 入力値検証が全エンドポイントで実施されている
- [ ] CORS設定が適切である
- [ ] 機密情報がレスポンスに含まれていない
- [ ] ログに機密情報が出力されない

**ドキュメント**
- [ ] OpenAPI 3.0形式で定義されている
- [ ] サンプルコードが複数言語で提供されている
- [ ] API仕様書の公開方法が明確である

**運用**
- [ ] ロギング・監視項目が定義されている
- [ ] テスト方針が明確である
- [ ] 変更管理ポリシーが定義されている
- [ ] 非推奨化プロセスが明確である

**外部連携（該当する場合）**
- [ ] 外部API連携仕様が定義されている
- [ ] Webhook仕様が定義されている
- [ ] エラーハンドリング、リトライポリシーが明確である

## 出力形式
- テンプレートの構造を維持
- 各項目を過不足なく埋める
- 表は見やすく整形
- JSON例は実際に動作する形式で記載
- コードサンプルは実行可能な形式で記載

## 記載時の注意事項

### 具体性
- 抽象的な表現を避け、具体的なエンドポイント、パラメータ、レスポンスを記載
- 例: ✗「適切なAPIを作成」→ ✓「GET /api/v1/users/{id}でユーザー詳細を取得」

### 要件との紐付け
- 各APIが要件のどの機能から導出されたか明記
- 例: 「要件定義書3.1.2のユーザー登録機能で使用」

### 実装可能性
- 技術的に実装可能なAPI設計
- 標準的なHTTPプロトコル、JSON形式を使用
- 特殊な技術を使う場合は理由を明記

### 一貫性
- 命名規則の統一（エンドポイント、JSONキー）
- エラーレスポンス形式の統一
- ページネーション形式の統一
- 日時形式の統一（ISO 8601）

### DB設計との整合性
- APIのリクエスト/レスポンスがDB設計のテーブル・カラムと対応
- 外部キー関係がAPIの階層構造に反映
- データ型の整合性

## 最終出力先
`詳細設計tmp/API設計.md` に保存してください。
