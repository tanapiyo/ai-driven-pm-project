# データベース設計作成プロンプト

## 目的
要件定義書の内容を基に、システムで扱うデータを効率的かつ安全に管理するためのデータベース設計書を作成します。

## インプット
以下のドキュメントを読み込んでください：
1. **要件定義書**: `[要件定義書のパス]`
2. **システム構成図**: `詳細設計tmp/システム構成図.md`（作成済みの場合）

## 出力指示
`詳細設計tmp/テンプレート/DB設計.md` のテンプレートを使用して、データベース設計書を作成してください。

## 作成ガイドライン

### 1. 要件定義書の分析
まず、以下の情報を要件定義書から抽出してください：

#### 1.1 データ要件の抽出
- **エンティティ**: 管理対象のデータの種類（ユーザー、商品、注文など）
- **属性**: 各エンティティが持つ項目
- **関連**: エンティティ間の関係性（1対多、多対多など）
- **データ量**: 初期件数、年間増加数の見積もり
- **データライフサイクル**: 保持期間、削除ポリシー

#### 1.2 機能要件からのデータ抽出
各機能要件を分析し、必要なデータを特定：
- 機能の入力項目 → カラム定義
- 機能の出力項目 → 検索条件、インデックス
- 機能の処理内容 → 制約、トリガー

#### 1.3 非機能要件の確認
- **性能要件**: レスポンスタイム、同時アクセス数 → インデックス戦略、パーティショニング
- **可用性要件**: ダウンタイム許容度 → レプリケーション構成
- **セキュリティ要件**: アクセス制御、暗号化要件
- **バックアップ要件**: RPO/RTO → バックアップ方針

### 2. データベース設計の進め方

#### ステップ1: 概念設計
1. **エンティティの抽出**: 要件からエンティティを洗い出し
2. **関連の定義**: エンティティ間の関係を定義
3. **主キーの決定**: 各エンティティの識別子を決定
4. **概念ER図の作成**: エンティティと関連を図示

#### ステップ2: 論理設計
1. **正規化**: 第3正規形までを原則とし、必要に応じて非正規化
2. **属性の詳細化**: データ型、桁数、NULL許可の決定
3. **制約の定義**: CHECK制約、UNIQUE制約、外部キー制約
4. **論理ER図の作成**: 属性を含む詳細なER図

#### ステップ3: 物理設計
1. **テーブル名・カラム名の決定**: 命名規則に従った命名
2. **データ型の最適化**: DBMS固有のデータ型選択
3. **インデックス設計**: 検索性能を考慮したインデックス配置
4. **パーティショニング検討**: 大量データテーブルの分割戦略
5. **容量見積**: ストレージ容量の算出

### 3. 各セクションの作成指示

#### 3.1 概要 (セクション2-3)
- システムで扱うデータの概要を記載
- 選定したDBMSとその理由（要件との関連性）
- 命名規則の定義（一貫性を保つため）
- 共通カラムの定義（created_at, updated_atなど）

#### 3.2 ER図 (セクション4)
- **概念ER図**: エンティティと関連のみを記載
- **論理ER図**: 属性を含む詳細な図
- Mermaid記法またはテキストベースで記載
- 多対多の関連は中間テーブルで表現

#### 3.3 テーブル定義 (セクション5)
各テーブルについて以下を定義：

**テーブル概要**
- 論理名・物理名
- 用途（どの機能で使われるか要件と紐付け）
- 想定件数（要件の利用者数、トランザクション数から算出）

**カラム定義**
- カラム名: 命名規則に従う
- データ型: 適切な型と桁数（例: 金額はNUMERIC、メールはVARCHAR(255)）
- NULL許可: NOT NULLが原則、NULL許可は理由を明記
- デフォルト値: 必要に応じて設定
- 説明: カラムの用途を明確に記載
- 備考: 値の範囲、フォーマット、計算ロジックなど

**インデックス定義**
- 主キー: 各テーブルに必須
- 外部キー: 参照整合性のため
- 検索用インデックス: WHERE句で使用するカラム
- 複合インデックス: 複数カラムでの検索が多い場合

**制約定義**
- CHECK制約: 値の範囲、列挙値のチェック
- UNIQUE制約: 一意性が必要なカラム（メールアドレスなど）
- 外部キー制約: 参照整合性の保証

#### 3.4 マスターデータ定義 (セクション6)
- マスターテーブルの一覧と更新頻度
- 初期データのINSERT文
- マスターデータの管理方法（画面からの登録、CSVインポートなど）

#### 3.5 ビュー定義 (セクション7)
- 頻繁に使用する複雑なSELECT文をビュー化
- 論理削除対応（deleted_at IS NULLの条件を含むビュー）
- セキュリティ対応（特定カラムを隠すビュー）

#### 3.6 インデックス戦略 (セクション8)
- インデックス設計の方針
- 複合インデックスの設計根拠
- インデックス数の適切な制限（書き込み性能とのトレードオフ）

#### 3.7 パーティショニング (セクション9)
- 大量データテーブル（年間100万件以上）が対象
- パーティション方式の選択（レンジ、リスト、ハッシュ）
- パーティションキーの選定（検索条件、データライフサイクルを考慮）

#### 3.8 データ容量見積 (セクション10)
- 1レコードあたりのサイズ計算
- 初期件数と年間増加数から将来件数を予測
- インデックス容量も考慮（データサイズの30-50%程度）
- 余裕を持った容量確保（見積の150-200%）

#### 3.9 データ保持・削除ポリシー (セクション11)
- 要件や法的要件から保持期間を決定
- 論理削除 vs 物理削除の使い分け
  - 論理削除: 復元可能性、監査証跡が必要な場合
  - 物理削除: ストレージ削減、個人情報保護が必要な場合
- データアーカイブ方針

#### 3.10 セキュリティ設計 (セクション12)
- **アクセス制御**: ロール別の権限設定
- **暗号化**:
  - パスワードはハッシュ化（bcrypt、Argon2など）
  - 個人情報は暗号化（AES-256など）
  - クレジットカード情報は保存しない（トークン化）
- **監査ログ**: 重要データの変更履歴記録

#### 3.11 バックアップ・リカバリ (セクション13)
- 要件のRPO/RTOを満たすバックアップ方式
- フルバックアップ + 増分/差分バックアップ
- トランザクションログのバックアップ
- リカバリ手順の明確化

#### 3.12 パフォーマンス設計 (セクション14)
- スロークエリの検出と対策
- 統計情報の定期更新
- コネクションプール設定（同時接続数要件から算出）
- クエリキャッシュの活用

#### 3.13 移行計画 (セクション15)
[既存システムからの移行がある場合]
- 移行元データの調査
- データマッピング定義
- データクレンジング方針
- 移行ツールの選定
- 移行リハーサル計画

### 4. 設計時の重要ポイント

#### 4.1 正規化と非正規化のバランス
- **原則**: 第3正規形まで正規化
- **非正規化を検討**:
  - 頻繁に結合されるテーブル（パフォーマンス改善）
  - 履歴データ（データの一貫性保持）
  - 集計値の保持（計算コスト削減）
- 非正規化する場合は理由を明記

#### 4.2 インデックス設計
- **作成すべきインデックス**:
  - 主キー（自動作成）
  - 外部キー
  - WHERE句で頻繁に使用するカラム
  - ORDER BY句で使用するカラム
- **複合インデックス**: カーディナリティの高いカラムを先頭に
- **過剰なインデックスは避ける**: INSERT/UPDATE性能が低下

#### 4.3 データ型の選択
- **文字列**:
  - 固定長→CHAR、可変長→VARCHAR、長文→TEXT
  - 国際化対応→UTF-8
- **数値**:
  - 整数→INT, BIGINT
  - 小数→DECIMAL（金額など正確性が必要）、FLOAT（科学計算）
- **日時**:
  - TIMESTAMP（タイムゾーン対応）、DATE、TIME
- **論理値**: BOOLEAN
- **列挙値**: VARCHAR + CHECK制約 or ENUM型

#### 4.4 制約の活用
- **NOT NULL制約**: 必須項目に設定
- **UNIQUE制約**: メールアドレス、コードなど
- **CHECK制約**: 値の範囲、列挙値のチェック
- **外部キー制約**: 参照整合性の保証
  - ON DELETE: RESTRICT（推奨）、CASCADE（注意して使用）
  - ON UPDATE: CASCADE（推奨）

#### 4.5 命名規則の一貫性
- テーブル名: 複数形、スネークケース（users, order_items）
- カラム名: スネークケース（user_id, created_at）
- プロジェクト全体で統一した命名規則を使用

### 5. チェックリスト
作成後、以下を確認してください：

**データモデル**
- [ ] 要件定義書の全エンティティがテーブル化されている
- [ ] エンティティ間の関連が正しく外部キーで表現されている
- [ ] 概念ER図と論理ER図が整合している
- [ ] 正規化が適切に行われている（第3正規形）
- [ ] 非正規化した場合は理由が明記されている

**テーブル定義**
- [ ] 全テーブルに主キーが定義されている
- [ ] 外部キーに対応するカラムが存在する
- [ ] データ型と桁数が適切である
- [ ] NULL許可/不許可が適切に設定されている
- [ ] デフォルト値が適切に設定されている
- [ ] 共通カラム（created_at, updated_atなど）が含まれている

**インデックス**
- [ ] 主キーにインデックスが設定されている
- [ ] 外部キーにインデックスが設定されている
- [ ] 検索条件で使用するカラムにインデックスが設定されている
- [ ] 過剰なインデックスがない

**制約**
- [ ] 参照整合性が外部キー制約で保証されている
- [ ] 値の範囲や列挙値がCHECK制約で保証されている
- [ ] 一意性がUNIQUE制約で保証されている

**パフォーマンス**
- [ ] 大量データテーブルにパーティショニングが検討されている
- [ ] インデックス戦略が明確である
- [ ] 容量見積が適切である

**セキュリティ**
- [ ] パスワードがハッシュ化される
- [ ] 個人情報の暗号化が検討されている
- [ ] アクセス制御が定義されている
- [ ] 監査ログが必要なテーブルで定義されている

**運用**
- [ ] バックアップ方針が要件のRPO/RTOを満たしている
- [ ] データ保持期間が定義されている
- [ ] 論理削除/物理削除の方針が明確である

**ドキュメント**
- [ ] 各テーブルの用途が明確に記載されている
- [ ] 各カラムの説明が記載されている
- [ ] 設計判断の理由が記載されている
- [ ] DDL生成スクリプトが記載されている

## 出力形式
- テンプレートの構造を維持
- 各項目を過不足なく埋める
- 表は見やすく整形
- ER図はMermaid形式またはテキストベースで記載
- SQL文は実行可能な形式で記載

## 記載時の注意事項

### 具体性
- 抽象的な表現を避け、具体的な値を記載
- 例: ✗「適切なインデックスを作成」→ ✓「emailカラムにユニークインデックスを作成」

### 要件との紐付け
- 各テーブル・カラムが要件のどの部分から導出されたか明記
- 例: 「要件定義書3.1.2のユーザー登録機能で使用」

### 実装可能性
- 選定したDBMSで実装可能な設計
- 標準SQLを基本とし、DBMS固有機能は明記

### 一貫性
- 命名規則の統一
- データ型の使用方針の統一
- 共通カラムの統一

## 最終出力先
`詳細設計tmp/DB設計.md` に保存してください。
